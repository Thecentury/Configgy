using System;
using System.Collections.Concurrent;

namespace Configgy.Cache
{
    /// <summary>
    /// A simple dictionary-based config cache.
    /// </summary>
    public class DictionaryCache : IValueCache
    {
        private readonly ConcurrentDictionary<GetValueArgs, object> _internal = new ConcurrentDictionary<GetValueArgs, object>();

        /// <summary>
        /// Remove all values from the cache.
        /// </summary>
        public void Clear()
        {
            _internal.Clear();
        }

        /// <summary>
        /// Gets a value from the cache.
        /// Produces the value using the callback if no value exists.
        /// </summary>
        /// <param name="settingName"></param>
        /// <param name="valueName">The name of the value to get.</param>
        /// <param name="valueCallback">The callback to use to produce the value if it is not in the cache.</param>
        /// <returns>The value, either from the cache or as generated by the callback.</returns>
        public object Get( string settingName, string valueName, Func<GetValueArgs, object> valueCallback )
        {
            return _internal.GetOrAdd(new GetValueArgs( settingName, valueName ), valueCallback);
        }

        /// <summary>
        /// Remove a value from the cache.
        /// </summary>
        /// <param name="settingName"></param>
        /// <param name="valueName">The name of the value to remove from the cache.</param>
        public void Remove(string settingName, string valueName)
        {
            _internal.TryRemove( new GetValueArgs( settingName, valueName ), out object _);
        }
    }
}
